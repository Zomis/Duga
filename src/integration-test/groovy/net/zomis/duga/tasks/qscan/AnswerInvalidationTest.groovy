package net.zomis.duga.tasks.qscan

import groovy.json.JsonSlurper
import net.zomis.duga.GithubBean
import net.zomis.duga.HookStringification
import net.zomis.duga.chat.WebhookParameters
import org.junit.Test
import org.springframework.core.env.Environment

class AnswerInvalidationTest {
    // https://grails.github.io/grails-doc/latest/guide/testing.html

    final TestBot bot = new TestBot()
    Environment env

    @Test
    public void test() {
        def stackAPI = new StackMockAPI()
        def questions = new JsonSlurper().parseText('''
{"items":[{"owner":{"reputation":38517,"user_id":31562,"user_type":"moderator","display_name":"Simon Forsberg","link":"http://codereview.stackexchange.com/users/31562/simon-forsberg"},"last_editor":{"reputation":38517,"user_id":31562,"user_type":"moderator","display_name":"Simon Forsberg","link":"http://codereview.stackexchange.com/users/31562/simon-forsberg"},"answer_count":1,"last_activity_date":1428425267,"creation_date":1428416878,"last_edit_date":1428420749,"question_id":86150,"link":"http://codereview.stackexchange.com/questions/86150/highest-pit-only-climbing-through-the-pit-once","body":"<p>For a problem description, see <a href=\\"http://codereview.stackexchange.com/questions/86139/highest-pit-algorithm/86142\\">other question</a>.</p>\\n\\n<p>Imagine I would write this code at an interview. What would you say?</p>\\n\\n<p>Time complexity: \\\\$O(n)\\\\$</p>\\n\\n<p>Space complexity: \\\\$O(n)\\\\$</p>\\n\\n<p>Auxiliary space complexity: \\\\$O(1)\\\\$</p>\\n\\n<pre><code>public class FindDeepestPit {\\n\\n    public static void main(String[] args) {\\n        int[] heights = { 0, 9, 6, -2, 7, 8, 0, -3, 2, 3 };\\n        int result = findDeepestPit(heights);\\n        System.out.println(result);\\n    }\\n\\n    private static int findDeepestPit(int[] heights) {\\n        int firstIndex = 0;\\n        int deepest = -1;\\n        int depth = 0;\\n        boolean climbingUp = false;\\n\\n        /*\\n        * mark current position as highest (firstIndex)\\n        * - go to next as long as we're going down\\n        * - when we're not going down anymore, switch to mark us going up\\n        * - go up until we can't go up anymore, then save the current depth of the pit, and mark the current position as highest\\n        * */\\n\\n        for (int i = 0; i &lt; heights.length - 1; i++) {\\n            int currentHeight = heights[i];\\n            int nextHeight = heights[i + 1];\\n            // find higher point\\n            if (!climbingUp) { // climbing down\\n                if (currentHeight &lt; nextHeight) {\\n                    // we can't go further down here\\n                    climbingUp = true;\\n                    deepest = i;\\n                }\\n            } else { // climbing up\\n                if (currentHeight &gt; nextHeight) {\\n                    // we can't get further up here.\\n                    int lastIndex = i;\\n                    int depthA = heights[firstIndex] - heights[deepest];\\n                    int depthB = heights[lastIndex] - heights[deepest];\\n                    int currDepth = Math.min(depthA, depthB);\\n                    depth = Math.max(depth, currDepth);\\n                    firstIndex = i;\\n                    climbingUp = false;\\n                }\\n            }\\n        }\\n\\n        int depthA = heights[firstIndex] - heights[deepest];\\n        int depthB = heights[heights.length - 1] - heights[deepest];\\n        int currDepth = Math.min(depthA, depthB);\\n        depth = Math.max(depth, currDepth);\\n\\n        return depth;\\n    }\\n}\\n</code></pre>\\n\\n<p>Primary concerns:</p>\\n\\n<ul>\\n<li>Is the approach clear?</li>\\n<li>Are there any edge cases I did not think about?</li>\\n<li>At an interview, would adding unit tests for this method be a good idea?</li>\\n</ul>\\n"}],"has_more":false,"quota_max":10000,"quota_remaining":8671}
        ''')

        def edits = new JsonSlurper().parseText('''
{"items":[{"user":{"reputation":38517,"user_id":31562,"user_type":"moderator","profile_image":"https://i.stack.imgur.com/7PmCG.jpg?s=128&g=1","display_name":"Simon Forsberg","link":"http://codereview.stackexchange.com/users/31562/simon-forsberg"},"set_community_wiki":false,"is_rollback":false,"creation_date":1428420749,"post_id":86150,"post_type":"question","revision_type":"single_user","revision_number":2,"body":"<p>For a problem description, see <a href=\\"http://codereview.stackexchange.com/questions/86139/highest-pit-algorithm/86142\\">other question</a>.</p>\\n\\n<p>Imagine I would write this code at an interview. What would you say?</p>\\n\\n<p>Time complexity: \\\\$O(n)\\\\$</p>\\n\\n<p>Space complexity: \\\\$O(n)\\\\$</p>\\n\\n<p>Auxiliary space complexity: \\\\$O(1)\\\\$</p>\\n\\n<pre><code>public class FindDeepestPit {\\n\\n    public static void main(String[] args) {\\n        int[] heights = { 0, 9, 6, -2, 7, 8, 0, -3, 2, 3 };\\n        int result = findDeepestPit(heights);\\n        System.out.println(result);\\n    }\\n\\n    private static int findDeepestPit(int[] heights) {\\n        int firstIndex = 0;\\n        int deepest = -1;\\n        int depth = 0;\\n        boolean climbingUp = false;\\n\\n        /*\\n        * mark current position as highest (firstIndex)\\n        * - go to next as long as we're going down\\n        * - when we're not going down anymore, switch to mark us going up\\n        * - go up until we can't go up anymore, then save the current depth of the pit, and mark the current position as highest\\n        * */\\n\\n        for (int i = 0; i &lt; heights.length - 1; i++) {\\n            int currentHeight = heights[i];\\n            int nextHeight = heights[i + 1];\\n            // find higher point\\n            if (!climbingUp) { // climbing down\\n                if (currentHeight &lt; nextHeight) {\\n                    // we can't go further down here\\n                    climbingUp = true;\\n                    deepest = i;\\n                }\\n            } else { // climbing up\\n                if (currentHeight &gt; nextHeight) {\\n                    // we can't get further up here.\\n                    int lastIndex = i;\\n                    int depthA = heights[firstIndex] - heights[deepest];\\n                    int depthB = heights[lastIndex] - heights[deepest];\\n                    int currDepth = Math.min(depthA, depthB);\\n                    depth = Math.max(depth, currDepth);\\n                    firstIndex = i;\\n                    climbingUp = false;\\n                }\\n            }\\n        }\\n\\n        int depthA = heights[firstIndex] - heights[deepest];\\n        int depthB = heights[heights.length - 1] - heights[deepest];\\n        int currDepth = Math.min(depthA, depthB);\\n        depth = Math.max(depth, currDepth);\\n\\n        return depth;\\n    }\\n}\\n</code></pre>\\n\\n<p>Primary concerns:</p>\\n\\n<ul>\\n<li>Is the approach clear?</li>\\n<li>Are there any edge cases I did not think about?</li>\\n<li>At an interview, would adding unit tests for this method be a good idea?</li>\\n</ul>\\n","last_body":"<p>For a problem description, see <a href=\\"http://codereview.stackexchange.com/questions/86139/highest-pit-algorithm/86142\\">other question</a>.</p>\\n\\n<p>Imagine I would write this code at an interview. What would you say?</p>\\n\\n<p>Time complexity: \\\\$O(n)\\\\$</p>\\n\\n<p>Space complexity: \\\\$O(n)\\\\$</p>\\n\\n<p>Auxiliary space complexity: \\\\$O(1)\\\\$</p>\\n\\n<pre><code>public class FindDeepestPit {\\n\\n    public static void main(String[] args) {\\n        int[] heights = { 0, 9, 6, -2, 7, 8, 0, -3, 2, 3 };\\n        int result = findDeepestPit(heights);\\n        System.out.println(result);\\n    }\\n\\n    private static int findDeepestPit(int[] heights) {\\n        int firstIndex = 0;\\n        int deepest = -1;\\n        int depth = 0;\\n        boolean climbingUp = false;\\n\\n        /*\\n        * mark current position as highest (firstIndex)\\n        * - go to next as long as we're going down\\n        * - when we're not going down anymore, switch to mark us going up\\n        * - go up until we can't go up anymore, then save the current depth of the pit, and mark the current position as highest\\n        * */\\n\\n        for (int i = 0; i &lt; heights.length - 1; i++) {\\n            int currentHeight = heights[i];\\n            int nextHeight = heights[i + 1];\\n            // find higher point\\n            if (!climbingUp) { // climbing down\\n                if (currentHeight &lt; nextHeight) {\\n                    // we can't go further down here\\n                    climbingUp = true;\\n                    deepest = i;\\n                }\\n            } else { // climbing up\\n                if (currentHeight &gt; nextHeight) {\\n                    // we can't get further up here.\\n                    int lastIndex = i;\\n                    int depthA = heights[firstIndex] - heights[deepest];\\n                    int depthB = heights[lastIndex] - heights[deepest];\\n                    int currDepth = Math.min(depthA, depthB);\\n                    depth = Math.max(depth, currDepth);\\n                    firstIndex = i;\\n                    climbingUp = false;\\n                }\\n            }\\n        }\\n        return depth;\\n    }\\n}\\n</code></pre>\\n\\n<p>Primary concerns:</p>\\n\\n<ul>\\n<li>Is the approach clear?</li>\\n<li>Are there any edge cases I did not think about?</li>\\n<li>At an interview, would adding unit tests for this method be a good idea?</li>\\n</ul>\\n","comment":"no answer yet - fixed edge case","revision_guid":"42D5AE55-6AF2-4F6C-95EA-E89ED324C875"},{"user":{"reputation":38517,"user_id":31562,"user_type":"moderator","profile_image":"https://i.stack.imgur.com/7PmCG.jpg?s=128&g=1","display_name":"Simon Forsberg","link":"http://codereview.stackexchange.com/users/31562/simon-forsberg"},"tags":["java","interview-questions","rags-to-riches"],"set_community_wiki":false,"is_rollback":false,"creation_date":1428416878,"post_id":86150,"post_type":"question","revision_type":"single_user","revision_number":1,"title":"Highest pit - only climbing through the pit once","body":"<p>For a problem description, see <a href=\\"http://codereview.stackexchange.com/questions/86139/highest-pit-algorithm/86142\\">other question</a>.</p>\\n\\n<p>Imagine I would write this code at an interview. What would you say?</p>\\n\\n<p>Time complexity: \\\\$O(n)\\\\$</p>\\n\\n<p>Space complexity: \\\\$O(n)\\\\$</p>\\n\\n<p>Auxiliary space complexity: \\\\$O(1)\\\\$</p>\\n\\n<pre><code>public class FindDeepestPit {\\n\\n    public static void main(String[] args) {\\n        int[] heights = { 0, 9, 6, -2, 7, 8, 0, -3, 2, 3 };\\n        int result = findDeepestPit(heights);\\n        System.out.println(result);\\n    }\\n\\n    private static int findDeepestPit(int[] heights) {\\n        int firstIndex = 0;\\n        int deepest = -1;\\n        int depth = 0;\\n        boolean climbingUp = false;\\n\\n        /*\\n        * mark current position as highest (firstIndex)\\n        * - go to next as long as we're going down\\n        * - when we're not going down anymore, switch to mark us going up\\n        * - go up until we can't go up anymore, then save the current depth of the pit, and mark the current position as highest\\n        * */\\n\\n        for (int i = 0; i &lt; heights.length - 1; i++) {\\n            int currentHeight = heights[i];\\n            int nextHeight = heights[i + 1];\\n            // find higher point\\n            if (!climbingUp) { // climbing down\\n                if (currentHeight &lt; nextHeight) {\\n                    // we can't go further down here\\n                    climbingUp = true;\\n                    deepest = i;\\n                }\\n            } else { // climbing up\\n                if (currentHeight &gt; nextHeight) {\\n                    // we can't get further up here.\\n                    int lastIndex = i;\\n                    int depthA = heights[firstIndex] - heights[deepest];\\n                    int depthB = heights[lastIndex] - heights[deepest];\\n                    int currDepth = Math.min(depthA, depthB);\\n                    depth = Math.max(depth, currDepth);\\n                    firstIndex = i;\\n                    climbingUp = false;\\n                }\\n            }\\n        }\\n        return depth;\\n    }\\n}\\n</code></pre>\\n\\n<p>Primary concerns:</p>\\n\\n<ul>\\n<li>Is the approach clear?</li>\\n<li>Are there any edge cases I did not think about?</li>\\n<li>At an interview, would adding unit tests for this method be a good idea?</li>\\n</ul>\\n","revision_guid":"EFA79ED7-D662-4E11-9ECB-E13BBBB6592D"}],"has_more":false,"quota_max":10000,"quota_remaining":8675}
        ''')

        stackAPI.expect(QuestionScanTask.LATEST_QUESTIONS, questions)
        stackAPI.expect(AnswerInvalidationCheck.editCall(86150), edits)

        QuestionScanTask task = new QuestionScanTask(stackAPI, new GithubBean(),
                new HookStringification(), bot,
                'codereview', 'answerInvalidation', 'roomAnswerInvalidation')
        task.run()
        def messages = bot.messages.get(WebhookParameters.toRoom('roomAnswerInvalidation'))

        assert messages == ['possible answer invalidation: http://codereview.stackexchange.com/questions/86150/highest-pit-only-climbing-through-the-pit-once'] : bot.messages
    }

}
